{"ast":null,"code":"// Load modules\nvar Utils = require('./utils'); // Declare internals\n\n\nvar internals = {\n  delimiter: '&',\n  depth: 5,\n  arrayLimit: 20,\n  parameterLimit: 1000\n};\n\ninternals.parseValues = function (str, options) {\n  var obj = {};\n  var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n  for (var i = 0, il = parts.length; i < il; ++i) {\n    var part = parts[i];\n    var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n    if (pos === -1) {\n      obj[Utils.decode(part)] = '';\n    } else {\n      var key = Utils.decode(part.slice(0, pos));\n      var val = Utils.decode(part.slice(pos + 1));\n\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        obj[key] = val;\n      } else {\n        obj[key] = [].concat(obj[key]).concat(val);\n      }\n    }\n  }\n\n  return obj;\n};\n\ninternals.parseObject = function (chain, val, options) {\n  if (!chain.length) {\n    return val;\n  }\n\n  var root = chain.shift();\n  var obj = {};\n\n  if (root === '[]') {\n    obj = [];\n    obj = obj.concat(internals.parseObject(chain, val, options));\n  } else {\n    var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n    var index = parseInt(cleanRoot, 10);\n    var indexString = '' + index;\n\n    if (!isNaN(index) && root !== cleanRoot && indexString === cleanRoot && index >= 0 && index <= options.arrayLimit) {\n      obj = [];\n      obj[index] = internals.parseObject(chain, val, options);\n    } else {\n      obj[cleanRoot] = internals.parseObject(chain, val, options);\n    }\n  }\n\n  return obj;\n};\n\ninternals.parseKeys = function (key, val, options) {\n  if (!key) {\n    return;\n  } // The regex chunks\n\n\n  var parent = /^([^\\[\\]]*)/;\n  var child = /(\\[[^\\[\\]]*\\])/g; // Get the parent\n\n  var segment = parent.exec(key); // Don't allow them to overwrite object prototype properties\n\n  if (Object.prototype.hasOwnProperty(segment[1])) {\n    return;\n  } // Stash the parent if it exists\n\n\n  var keys = [];\n\n  if (segment[1]) {\n    keys.push(segment[1]);\n  } // Loop through children appending to the array until we hit depth\n\n\n  var i = 0;\n\n  while ((segment = child.exec(key)) !== null && i < options.depth) {\n    ++i;\n\n    if (!Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n      keys.push(segment[1]);\n    }\n  } // If there's a remainder, just add whatever is left\n\n\n  if (segment) {\n    keys.push('[' + key.slice(segment.index) + ']');\n  }\n\n  return internals.parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, options) {\n  if (str === '' || str === null || typeof str === 'undefined') {\n    return {};\n  }\n\n  options = options || {};\n  options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n  options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n  options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n  options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n  var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n  var obj = {}; // Iterate over the keys and setup the new object\n\n  var keys = Object.keys(tempObj);\n\n  for (var i = 0, il = keys.length; i < il; ++i) {\n    var key = keys[i];\n    var newObj = internals.parseKeys(key, tempObj[key], options);\n    obj = Utils.merge(obj, newObj);\n  }\n\n  return Utils.compact(obj);\n};","map":null,"metadata":{},"sourceType":"script"}