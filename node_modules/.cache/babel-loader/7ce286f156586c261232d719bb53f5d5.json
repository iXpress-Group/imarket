{"ast":null,"code":"var optional = require('./lib/optional'),\n    http = require('http'),\n    https = optional('https'),\n    tls = optional('tls'),\n    url = require('url'),\n    util = require('util'),\n    stream = require('stream'),\n    qs = require('qs'),\n    querystring = require('querystring'),\n    crypto = require('crypto'),\n    oauth = optional('oauth-sign'),\n    hawk = optional('hawk'),\n    aws = optional('aws-sign2'),\n    httpSignature = optional('http-signature'),\n    uuid = require('node-uuid'),\n    mime = require('mime'),\n    tunnel = optional('tunnel-agent'),\n    _safeStringify = require('json-stringify-safe'),\n    ForeverAgent = require('forever-agent'),\n    FormData = optional('form-data'),\n    cookies = require('./lib/cookies'),\n    globalCookieJar = cookies.jar(),\n    copy = require('./lib/copy'),\n    debug = require('./lib/debug'),\n    getSafe = require('./lib/getSafe'),\n    net = require('net');\n\nfunction safeStringify(obj) {\n  var ret;\n\n  try {\n    ret = JSON.stringify(obj);\n  } catch (e) {\n    ret = _safeStringify(obj);\n  }\n\n  return ret;\n}\n\nvar globalPool = {};\nvar isUrl = /^https?:|^unix:/; // Hacky fix for pre-0.4.4 https\n\nif (https && !https.Agent) {\n  https.Agent = function (options) {\n    http.Agent.call(this, options);\n  };\n\n  util.inherits(https.Agent, http.Agent);\n\n  https.Agent.prototype._getConnection = function (host, port, cb) {\n    var s = tls.connect(port, host, this.options, function () {\n      // do other checks here?\n      if (cb) cb();\n    });\n    return s;\n  };\n}\n\nfunction isReadStream(rs) {\n  return rs.readable && rs.path && rs.mode;\n}\n\nfunction toBase64(str) {\n  return new Buffer(str || \"\", \"ascii\").toString(\"base64\");\n}\n\nfunction md5(str) {\n  return crypto.createHash('md5').update(str).digest('hex');\n}\n\nfunction Request(options) {\n  stream.Stream.call(this);\n  this.readable = true;\n  this.writable = true;\n\n  if (typeof options === 'string') {\n    options = {\n      uri: options\n    };\n  }\n\n  var reserved = Object.keys(Request.prototype);\n\n  for (var i in options) {\n    if (reserved.indexOf(i) === -1) {\n      this[i] = options[i];\n    } else {\n      if (typeof options[i] === 'function') {\n        delete options[i];\n      }\n    }\n  }\n\n  if (options.method) {\n    this.explicitMethod = true;\n  }\n\n  this.canTunnel = options.tunnel !== false && tunnel;\n  this.init(options);\n}\n\nutil.inherits(Request, stream.Stream);\n\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this;\n  if (!options) options = {};\n  if (!self.method) self.method = options.method || 'GET';\n  self.localAddress = options.localAddress;\n  debug(options);\n  if (!self.pool && self.pool !== false) self.pool = globalPool;\n  self.dests = self.dests || [];\n  self.__isRequestRequest = true; // Protect against double callback\n\n  if (!self._callback && self.callback) {\n    self._callback = self.callback;\n\n    self.callback = function () {\n      if (self._callbackCalled) return; // Print a warning maybe?\n\n      self._callbackCalled = true;\n\n      self._callback.apply(self, arguments);\n    };\n\n    self.on('error', self.callback.bind());\n    self.on('complete', self.callback.bind(self, null));\n  }\n\n  if (self.url && !self.uri) {\n    // People use this property instead all the time so why not just support it.\n    self.uri = self.url;\n    delete self.url;\n  }\n\n  if (!self.uri) {\n    // this will throw if unhandled but is handleable when in a redirect\n    return self.emit('error', new Error(\"options.uri is a required argument\"));\n  } else {\n    if (typeof self.uri == \"string\") self.uri = url.parse(self.uri);\n  }\n\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false;\n  }\n\n  if (self.proxy) {\n    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy); // do the HTTP CONNECT dance using koichik/node-tunnel\n\n    if (http.globalAgent && self.uri.protocol === \"https:\" && self.canTunnel) {\n      var tunnelFn = self.proxy.protocol === \"http:\" ? tunnel.httpsOverHttp : tunnel.httpsOverHttps;\n      var tunnelOptions = {\n        proxy: {\n          host: self.proxy.hostname,\n          port: +self.proxy.port,\n          proxyAuth: self.proxy.auth,\n          headers: {\n            Host: self.uri.hostname + ':' + (self.uri.port || self.uri.protocol === 'https:' ? 443 : 80)\n          }\n        },\n        rejectUnauthorized: self.rejectUnauthorized,\n        ca: this.ca\n      };\n      self.agent = tunnelFn(tunnelOptions);\n      self.tunnel = true;\n    }\n  }\n\n  if (!self.uri.pathname) {\n    self.uri.pathname = '/';\n  }\n\n  if (!self.uri.host && !self.protocol == 'unix:') {\n    // Invalid URI: it may generate lot of bad errors, like \"TypeError: Cannot call method 'indexOf' of undefined\" in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri);\n    var message = 'Invalid URI \"' + faultyUri + '\"';\n\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.';\n    }\n\n    self.emit('error', new Error(message));\n    return; // This error was fatal\n  }\n\n  self._redirectsFollowed = self._redirectsFollowed || 0;\n  self.maxRedirects = self.maxRedirects !== undefined ? self.maxRedirects : 10;\n  self.followRedirect = self.followRedirect !== undefined ? self.followRedirect : true;\n  self.followAllRedirects = self.followAllRedirects !== undefined ? self.followAllRedirects : false;\n  if (self.followRedirect || self.followAllRedirects) self.redirects = self.redirects || [];\n  self.headers = self.headers ? copy(self.headers) : {};\n  self.setHost = false;\n\n  if (!self.hasHeader('host')) {\n    self.setHeader('host', self.uri.hostname);\n\n    if (self.uri.port) {\n      if (!(self.uri.port === 80 && self.uri.protocol === 'http:') && !(self.uri.port === 443 && self.uri.protocol === 'https:')) self.setHeader('host', self.getHeader('host') + (':' + self.uri.port));\n    }\n\n    self.setHost = true;\n  }\n\n  self.jar(self._jar || options.jar);\n\n  if (!self.uri.port) {\n    if (self.uri.protocol == 'http:') {\n      self.uri.port = 80;\n    } else if (self.uri.protocol == 'https:') {\n      self.uri.port = 443;\n    }\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port;\n    self.host = self.proxy.hostname;\n  } else {\n    self.port = self.uri.port;\n    self.host = self.uri.hostname;\n  }\n\n  self.clientErrorHandler = function (error) {\n    if (self._aborted) return;\n\n    if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' && self.agent.addRequestNoreuse) {\n      self.agent = {\n        addRequest: self.agent.addRequestNoreuse.bind(self.agent)\n      };\n      self.start();\n      self.req.end();\n      return;\n    }\n\n    if (self.timeout && self.timeoutTimer) {\n      clearTimeout(self.timeoutTimer);\n      self.timeoutTimer = null;\n    }\n\n    self.emit('error', error);\n  };\n\n  self._parserErrorHandler = function (error) {\n    if (this.res) {\n      if (this.res.request) {\n        this.res.request.emit('error', error);\n      } else {\n        this.res.emit('error', error);\n      }\n    } else {\n      this._httpMessage.emit('error', error);\n    }\n  };\n\n  self._buildRequest = function () {\n    var self = this;\n\n    if (options.form) {\n      self.form(options.form);\n    }\n\n    if (options.qs) self.qs(options.qs);\n\n    if (self.uri.path) {\n      self.path = self.uri.path;\n    } else {\n      self.path = self.uri.pathname + (self.uri.search || \"\");\n    }\n\n    if (self.path.length === 0) self.path = '/'; // Auth must happen last in case signing is dependent on other headers\n\n    if (options.oauth) {\n      self.oauth(options.oauth);\n    }\n\n    if (options.aws) {\n      self.aws(options.aws);\n    }\n\n    if (options.hawk) {\n      self.hawk(options.hawk);\n    }\n\n    if (options.httpSignature) {\n      self.httpSignature(options.httpSignature);\n    }\n\n    if (options.auth) {\n      if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) options.auth.user = options.auth.username;\n      if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) options.auth.pass = options.auth.password;\n      self.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately);\n    }\n\n    if (self.uri.auth && !self.hasHeader('authorization')) {\n      var authPieces = self.uri.auth.split(':').map(function (item) {\n        return querystring.unescape(item);\n      });\n      self.auth(authPieces[0], authPieces.slice(1).join(':'), true);\n    }\n\n    if (self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization') && !self.tunnel) {\n      self.setHeader('proxy-authorization', \"Basic \" + toBase64(self.proxy.auth.split(':').map(function (item) {\n        return querystring.unescape(item);\n      }).join(':')));\n    }\n\n    if (self.proxy && !self.tunnel) self.path = self.uri.protocol + '//' + self.uri.host + self.path;\n\n    if (options.json) {\n      self.json(options.json);\n    } else if (options.multipart) {\n      self.boundary = uuid();\n      self.multipart(options.multipart);\n    }\n\n    if (self.body) {\n      var length = 0;\n\n      if (!Buffer.isBuffer(self.body)) {\n        if (Array.isArray(self.body)) {\n          for (var i = 0; i < self.body.length; i++) {\n            length += self.body[i].length;\n          }\n        } else {\n          self.body = new Buffer(self.body);\n          length = self.body.length;\n        }\n      } else {\n        length = self.body.length;\n      }\n\n      if (length) {\n        if (!self.hasHeader('content-length')) self.setHeader('content-length', length);\n      } else {\n        throw new Error('Argument error, options.body.');\n      }\n    }\n\n    var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol,\n        defaultModules = {\n      'http:': http,\n      'https:': https,\n      'unix:': http\n    },\n        httpModules = self.httpModules || {};\n    self.httpModule = httpModules[protocol] || defaultModules[protocol];\n    if (!self.httpModule) return this.emit('error', new Error(\"Invalid protocol\"));\n    if (options.ca) self.ca = options.ca;\n\n    if (!self.agent) {\n      if (options.agentOptions) self.agentOptions = options.agentOptions;\n\n      if (options.agentClass) {\n        self.agentClass = options.agentClass;\n      } else if (options.forever) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL;\n      } else {\n        self.agentClass = self.httpModule.Agent;\n      }\n    }\n\n    if (self.pool === false) {\n      self.agent = false;\n    } else {\n      self.agent = self.agent || self.getAgent();\n\n      if (self.maxSockets) {\n        // Don't use our pooling if node has the refactored client\n        self.agent.maxSockets = self.maxSockets;\n      }\n\n      if (self.pool.maxSockets) {\n        // Don't use our pooling if node has the refactored client\n        self.agent.maxSockets = self.pool.maxSockets;\n      }\n    }\n\n    self.on('pipe', function (src) {\n      if (self.ntick && self._started) throw new Error(\"You cannot pipe to this stream after the outbound request has started.\");\n      self.src = src;\n\n      if (isReadStream(src)) {\n        if (!self.hasHeader('content-type')) self.setHeader('content-type', mime.lookup(src.path));\n      } else {\n        if (src.headers) {\n          for (var i in src.headers) {\n            if (!self.hasHeader(i)) {\n              self.setHeader(i, src.headers[i]);\n            }\n          }\n        }\n\n        if (self._json && !self.hasHeader('content-type')) self.setHeader('content-type', 'application/json');\n\n        if (src.method && !self.explicitMethod) {\n          self.method = src.method;\n        }\n      } // self.on('pipe', function () {\n      //   console.error(\"You have already piped to this stream. Pipeing twice is likely to break the request.\")\n      // })\n\n    });\n    process.nextTick(function () {\n      if (self._aborted) return;\n\n      if (self._form) {\n        self.setHeaders(self._form.getHeaders());\n\n        try {\n          var length = self._form.getLengthSync();\n\n          self.setHeader('content-length', length);\n        } catch (e) {}\n\n        self._form.pipe(self);\n      }\n\n      if (self.body) {\n        if (Array.isArray(self.body)) {\n          self.body.forEach(function (part) {\n            self.write(part);\n          });\n        } else {\n          self.write(self.body);\n        }\n\n        self.end();\n      } else if (self.requestBodyStream) {\n        console.warn(\"options.requestBodyStream is deprecated, please pass the request object to stream.pipe.\");\n        self.requestBodyStream.pipe(self);\n      } else if (!self.src) {\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0);\n        }\n\n        self.end();\n      }\n\n      self.ntick = true;\n    });\n  }; // End _buildRequest\n\n\n  self._handleUnixSocketURI = function (self) {\n    // Parse URI and extract a socket path (tested as a valid socket using net.connect), and a http style path suffix\n    // Thus http requests can be made to a socket using the uri unix://tmp/my.socket/urlpath\n    // and a request for '/urlpath' will be sent to the unix socket at /tmp/my.socket\n    self.unixsocket = true;\n    var full_path = self.uri.href.replace(self.uri.protocol + '/', '');\n    var lookup = full_path.split('/');\n    var error_connecting = true;\n    var lookup_table = {};\n\n    do {\n      lookup_table[lookup.join('/')] = {};\n    } while (lookup.pop());\n\n    for (r in lookup_table) {\n      try_next(r);\n    }\n\n    function try_next(table_row) {\n      var client = net.connect(table_row);\n      client.path = table_row;\n      client.on('error', function () {\n        lookup_table[this.path].error_connecting = true;\n        this.end();\n      });\n      client.on('connect', function () {\n        lookup_table[this.path].error_connecting = false;\n        this.end();\n      });\n      table_row.client = client;\n    }\n\n    wait_for_socket_response();\n    response_counter = 0;\n\n    function wait_for_socket_response() {\n      var detach;\n      if ('undefined' == typeof setImmediate) detach = process.nextTick;else detach = setImmediate;\n      detach(function () {\n        // counter to prevent infinite blocking waiting for an open socket to be found.\n        response_counter++;\n        var trying = false;\n\n        for (r in lookup_table) {\n          //console.log(r, lookup_table[r], lookup_table[r].error_connecting)\n          if ('undefined' == typeof lookup_table[r].error_connecting) trying = true;\n        }\n\n        if (trying && response_counter < 1000) wait_for_socket_response();else set_socket_properties();\n      });\n    }\n\n    function set_socket_properties() {\n      var host;\n\n      for (r in lookup_table) {\n        if (lookup_table[r].error_connecting === false) {\n          host = r;\n        }\n      }\n\n      if (!host) {\n        self.emit('error', new Error(\"Failed to connect to any socket in \" + full_path));\n      }\n\n      var path = full_path.replace(host, '');\n      self.socketPath = host;\n      self.uri.pathname = path;\n      self.uri.href = path;\n      self.uri.path = path;\n      self.host = '';\n      self.hostname = '';\n      delete self.host;\n      delete self.hostname;\n\n      self._buildRequest();\n    }\n  }; // Intercept UNIX protocol requests to change properties to match socket\n\n\n  if (/^unix:/.test(self.uri.protocol)) {\n    self._handleUnixSocketURI(self);\n  } else {\n    self._buildRequest();\n  }\n}; // Must call this when following a redirect from https to http or vice versa\n// Attempts to keep everything as identical as possible, but update the\n// httpModule, Tunneling agent, and/or Forever Agent in use.\n\n\nRequest.prototype._updateProtocol = function () {\n  var self = this;\n  var protocol = self.uri.protocol;\n\n  if (protocol === 'https:') {\n    // previously was doing http, now doing https\n    // if it's https, then we might need to tunnel now.\n    if (self.proxy && self.canTunnel) {\n      self.tunnel = true;\n      var tunnelFn = self.proxy.protocol === 'http:' ? tunnel.httpsOverHttp : tunnel.httpsOverHttps;\n      var tunnelOptions = {\n        proxy: {\n          host: self.proxy.hostname,\n          port: +self.proxy.port,\n          proxyAuth: self.proxy.auth\n        },\n        rejectUnauthorized: self.rejectUnauthorized,\n        ca: self.ca\n      };\n      self.agent = tunnelFn(tunnelOptions);\n      return;\n    }\n\n    self.httpModule = https;\n\n    switch (self.agentClass) {\n      case ForeverAgent:\n        self.agentClass = ForeverAgent.SSL;\n        break;\n\n      case http.Agent:\n        self.agentClass = https.Agent;\n        break;\n\n      default:\n        // nothing we can do.  Just hope for the best.\n        return;\n    } // if there's an agent, we need to get a new one.\n\n\n    if (self.agent) self.agent = self.getAgent();\n  } else {\n    // previously was doing https, now doing http\n    // stop any tunneling.\n    if (self.tunnel) self.tunnel = false;\n    self.httpModule = http;\n\n    switch (self.agentClass) {\n      case ForeverAgent.SSL:\n        self.agentClass = ForeverAgent;\n        break;\n\n      case https.Agent:\n        self.agentClass = http.Agent;\n        break;\n\n      default:\n        // nothing we can do.  just hope for the best\n        return;\n    } // if there's an agent, then get a new one.\n\n\n    if (self.agent) {\n      self.agent = null;\n      self.agent = self.getAgent();\n    }\n  }\n};\n\nRequest.prototype.getAgent = function () {\n  var Agent = this.agentClass;\n  var options = {};\n\n  if (this.agentOptions) {\n    for (var i in this.agentOptions) {\n      options[i] = this.agentOptions[i];\n    }\n  }\n\n  if (this.ca) options.ca = this.ca;\n  if (this.ciphers) options.ciphers = this.ciphers;\n  if (this.secureProtocol) options.secureProtocol = this.secureProtocol;\n  if (typeof this.rejectUnauthorized !== 'undefined') options.rejectUnauthorized = this.rejectUnauthorized;\n\n  if (this.cert && this.key) {\n    options.key = this.key;\n    options.cert = this.cert;\n  }\n\n  var poolKey = ''; // different types of agents are in different pools\n\n  if (Agent !== this.httpModule.Agent) {\n    poolKey += Agent.name;\n  }\n\n  if (!this.httpModule.globalAgent) {\n    // node 0.4.x\n    options.host = this.host;\n    options.port = this.port;\n    if (poolKey) poolKey += ':';\n    poolKey += this.host + ':' + this.port;\n  } // ca option is only relevant if proxy or destination are https\n\n\n  var proxy = this.proxy;\n  if (typeof proxy === 'string') proxy = url.parse(proxy);\n  var isHttps = proxy && proxy.protocol === 'https:' || this.uri.protocol === 'https:';\n\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) poolKey += ':';\n      poolKey += options.ca;\n    }\n\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) poolKey += ':';\n      poolKey += options.rejectUnauthorized;\n    }\n\n    if (options.cert) poolKey += options.cert.toString('ascii') + options.key.toString('ascii');\n\n    if (options.ciphers) {\n      if (poolKey) poolKey += ':';\n      poolKey += options.ciphers;\n    }\n\n    if (options.secureProtocol) {\n      if (poolKey) poolKey += ':';\n      poolKey += options.secureProtocol;\n    }\n  }\n\n  if (this.pool === globalPool && !poolKey && Object.keys(options).length === 0 && this.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return this.httpModule.globalAgent;\n  } // we're using a stored agent.  Make sure it's protocol-specific\n\n\n  poolKey = this.uri.protocol + poolKey; // already generated an agent for this setting\n\n  if (this.pool[poolKey]) return this.pool[poolKey];\n  return this.pool[poolKey] = new Agent(options);\n};\n\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this;\n  if (self._aborted) return;\n  self._started = true;\n  self.method = self.method || 'GET';\n  self.href = self.uri.href;\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size);\n  }\n\n  if (self._aws) {\n    self.aws(self._aws, true);\n  } // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n\n\n  var reqOptions = copy(self);\n  delete reqOptions.auth;\n  debug('make request', self.uri.href);\n  self.req = self.httpModule.request(reqOptions, self.onResponse.bind(self));\n\n  if (self.timeout && !self.timeoutTimer) {\n    self.timeoutTimer = setTimeout(function () {\n      self.req.abort();\n      var e = new Error(\"ETIMEDOUT\");\n      e.code = \"ETIMEDOUT\";\n      self.emit(\"error\", e);\n    }, self.timeout); // Set additional timeout on socket - in case if remote\n    // server freeze after sending headers\n\n    if (self.req.setTimeout) {\n      // only works on node 0.6+\n      self.req.setTimeout(self.timeout, function () {\n        if (self.req) {\n          self.req.abort();\n          var e = new Error(\"ESOCKETTIMEDOUT\");\n          e.code = \"ESOCKETTIMEDOUT\";\n          self.emit(\"error\", e);\n        }\n      });\n    }\n  }\n\n  self.req.on('error', self.clientErrorHandler);\n  self.req.on('drain', function () {\n    self.emit('drain');\n  });\n  self.on('end', function () {\n    if (self.req.connection) self.req.connection.removeListener('error', self._parserErrorHandler);\n  });\n  self.emit('request', self.req);\n};\n\nRequest.prototype.onResponse = function (response) {\n  var self = this;\n  debug('onResponse', self.uri.href, response.statusCode, response.headers);\n  response.on('end', function () {\n    debug('response end', self.uri.href, response.statusCode, response.headers);\n  });\n\n  if (response.connection.listeners('error').indexOf(self._parserErrorHandler) === -1) {\n    response.connection.once('error', self._parserErrorHandler);\n  }\n\n  if (self._aborted) {\n    debug('aborted', self.uri.href);\n    response.resume();\n    return;\n  }\n\n  if (self._paused) response.pause();else response.resume();\n  self.response = response;\n  response.request = self;\n  response.toJSON = toJSON; // XXX This is different on 0.10, because SSL is strict by default\n\n  if (self.httpModule === https && self.strictSSL && !response.client.authorized) {\n    debug('strict ssl error', self.uri.href);\n    var sslErr = response.client.authorizationError;\n    self.emit('error', new Error('SSL Error: ' + sslErr));\n    return;\n  }\n\n  if (self.setHost && self.hasHeader('host')) delete self.headers[self.hasHeader('host')];\n\n  if (self.timeout && self.timeoutTimer) {\n    clearTimeout(self.timeoutTimer);\n    self.timeoutTimer = null;\n  }\n\n  var targetCookieJar = self._jar && self._jar.setCookie ? self._jar : globalCookieJar;\n\n  var addCookie = function (cookie) {\n    //set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {\n        ignoreError: true\n      });\n    } catch (e) {\n      self.emit('error', e);\n    }\n  };\n\n  if (hasHeader('set-cookie', response.headers) && !self._disableCookies) {\n    var headerName = hasHeader('set-cookie', response.headers);\n    if (Array.isArray(response.headers[headerName])) response.headers[headerName].forEach(addCookie);else addCookie(response.headers[headerName]);\n  }\n\n  var redirectTo = null;\n\n  if (response.statusCode >= 300 && response.statusCode < 400 && hasHeader('location', response.headers)) {\n    var location = response.headers[hasHeader('location', response.headers)];\n    debug('redirect', location);\n\n    if (self.followAllRedirects) {\n      redirectTo = location;\n    } else if (self.followRedirect) {\n      switch (self.method) {\n        case 'PATCH':\n        case 'PUT':\n        case 'POST':\n        case 'DELETE':\n          // Do not follow redirects\n          break;\n\n        default:\n          redirectTo = location;\n          break;\n      }\n    }\n  } else if (response.statusCode == 401 && self._hasAuth && !self._sentAuth) {\n    var authHeader = response.headers[hasHeader('www-authenticate', response.headers)];\n    var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase();\n    debug('reauth', authVerb);\n\n    switch (authVerb) {\n      case 'basic':\n        self.auth(self._user, self._pass, true);\n        redirectTo = self.uri;\n        break;\n\n      case 'digest':\n        // TODO: More complete implementation of RFC 2617.\n        //   - check challenge.algorithm\n        //   - support algorithm=\"MD5-sess\"\n        //   - handle challenge.domain\n        //   - support qop=\"auth-int\" only\n        //   - handle Authentication-Info (not necessarily?)\n        //   - check challenge.stale (not necessarily?)\n        //   - increase nc (not necessarily?)\n        // For reference:\n        // http://tools.ietf.org/html/rfc2617#section-3\n        // https://github.com/bagder/curl/blob/master/lib/http_digest.c\n        var challenge = {};\n        var re = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/gi;\n\n        for (;;) {\n          var match = re.exec(authHeader);\n          if (!match) break;\n          challenge[match[1]] = match[2] || match[3];\n        }\n\n        var ha1 = md5(self._user + ':' + challenge.realm + ':' + self._pass);\n        var ha2 = md5(self.method + ':' + self.uri.path);\n        var qop = /(^|,)\\s*auth\\s*($|,)/.test(challenge.qop) && 'auth';\n        var nc = qop && '00000001';\n        var cnonce = qop && uuid().replace(/-/g, '');\n        var digestResponse = qop ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2) : md5(ha1 + ':' + challenge.nonce + ':' + ha2);\n        var authValues = {\n          username: self._user,\n          realm: challenge.realm,\n          nonce: challenge.nonce,\n          uri: self.uri.path,\n          qop: qop,\n          response: digestResponse,\n          nc: nc,\n          cnonce: cnonce,\n          algorithm: challenge.algorithm,\n          opaque: challenge.opaque\n        };\n        authHeader = [];\n\n        for (var k in authValues) {\n          if (!authValues[k]) {//ignore\n          } else if (k === 'qop' || k === 'nc' || k === 'algorithm') {\n            authHeader.push(k + '=' + authValues[k]);\n          } else {\n            authHeader.push(k + '=\"' + authValues[k] + '\"');\n          }\n        }\n\n        authHeader = 'Digest ' + authHeader.join(', ');\n        self.setHeader('authorization', authHeader);\n        self._sentAuth = true;\n        redirectTo = self.uri;\n        break;\n    }\n  }\n\n  if (redirectTo) {\n    debug('redirect to', redirectTo); // ignore any potential response body.  it cannot possibly be useful\n    // to us at this point.\n\n    if (self._paused) response.resume();\n\n    if (self._redirectsFollowed >= self.maxRedirects) {\n      self.emit('error', new Error(\"Exceeded maxRedirects. Probably stuck in a redirect loop \" + self.uri.href));\n      return;\n    }\n\n    self._redirectsFollowed += 1;\n\n    if (!isUrl.test(redirectTo)) {\n      redirectTo = url.resolve(self.uri.href, redirectTo);\n    }\n\n    var uriPrev = self.uri;\n    self.uri = url.parse(redirectTo); // handle the case where we change protocol from https to http or vice versa\n\n    if (self.uri.protocol !== uriPrev.protocol) {\n      self._updateProtocol();\n    }\n\n    self.redirects.push({\n      statusCode: response.statusCode,\n      redirectUri: redirectTo\n    });\n    if (self.followAllRedirects && response.statusCode != 401) self.method = 'GET'; // self.method = 'GET' // Force all redirects to use GET || commented out fixes #215\n\n    delete self.src;\n    delete self.req;\n    delete self.agent;\n    delete self._started;\n\n    if (response.statusCode != 401) {\n      // Remove parameters from the previous response, unless this is the second request\n      // for a server that requires digest authentication.\n      delete self.body;\n      delete self._form;\n\n      if (self.headers) {\n        if (self.hasHeader('host')) delete self.headers[self.hasHeader('host')];\n        if (self.hasHeader('content-type')) delete self.headers[self.hasHeader('content-type')];\n        if (self.hasHeader('content-length')) delete self.headers[self.hasHeader('content-length')];\n      }\n    }\n\n    self.emit('redirect');\n    self.init();\n    return; // Ignore the rest of the response\n  } else {\n    self._redirectsFollowed = self._redirectsFollowed || 0; // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n\n    response.on('close', function () {\n      if (!self._ended) self.response.emit('end');\n    });\n\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error(\"Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.\");\n      } else {\n        response.setEncoding(self.encoding);\n      }\n    }\n\n    self.emit('response', response);\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest);\n    });\n    response.on(\"data\", function (chunk) {\n      self._destdata = true;\n      self.emit(\"data\", chunk);\n    });\n    response.on(\"end\", function (chunk) {\n      self._ended = true;\n      self.emit(\"end\", chunk);\n    });\n    response.on(\"close\", function () {\n      self.emit(\"close\");\n    });\n\n    if (self.callback) {\n      var buffer = [];\n      var bodyLen = 0;\n      self.on(\"data\", function (chunk) {\n        buffer.push(chunk);\n        bodyLen += chunk.length;\n      });\n      self.on(\"end\", function () {\n        debug('end event', self.uri.href);\n\n        if (self._aborted) {\n          debug('aborted', self.uri.href);\n          return;\n        }\n\n        if (buffer.length && Buffer.isBuffer(buffer[0])) {\n          debug('has body', self.uri.href, bodyLen);\n          var body = new Buffer(bodyLen);\n          var i = 0;\n          buffer.forEach(function (chunk) {\n            chunk.copy(body, i, 0, chunk.length);\n            i += chunk.length;\n          });\n\n          if (self.encoding === null) {\n            response.body = body;\n          } else {\n            response.body = body.toString(self.encoding);\n          }\n        } else if (buffer.length) {\n          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n          // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n          if (self.encoding === 'utf8' && buffer[0].length > 0 && buffer[0][0] === \"\\uFEFF\") {\n            buffer[0] = buffer[0].substring(1);\n          }\n\n          response.body = buffer.join('');\n        }\n\n        if (self._json) {\n          try {\n            response.body = JSON.parse(response.body);\n          } catch (e) {}\n        }\n\n        debug('emitting complete', self.uri.href);\n\n        if (response.body == undefined && !self._json) {\n          response.body = \"\";\n        }\n\n        self.emit('complete', response, response.body);\n      });\n    } //if no callback\n    else {\n        self.on(\"end\", function () {\n          if (self._aborted) {\n            debug('aborted', self.uri.href);\n            return;\n          }\n\n          self.emit('complete', response);\n        });\n      }\n  }\n\n  debug('finish init function', self.uri.href);\n};\n\nRequest.prototype.abort = function () {\n  this._aborted = true;\n\n  if (this.req) {\n    this.req.abort();\n  } else if (this.response) {\n    this.response.abort();\n  }\n\n  this.emit(\"abort\");\n};\n\nRequest.prototype.pipeDest = function (dest) {\n  var response = this.response; // Called after the response is received\n\n  if (dest.headers && !dest.headersSent) {\n    if (hasHeader('content-type', response.headers)) {\n      var ctname = hasHeader('content-type', response.headers);\n      if (dest.setHeader) dest.setHeader(ctname, response.headers[ctname]);else dest.headers[ctname] = response.headers[ctname];\n    }\n\n    if (hasHeader('content-length', response.headers)) {\n      var clname = hasHeader('content-length', response.headers);\n      if (dest.setHeader) dest.setHeader(clname, response.headers[clname]);else dest.headers[clname] = response.headers[clname];\n    }\n  }\n\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      dest.setHeader(i, response.headers[i]);\n    }\n\n    dest.statusCode = response.statusCode;\n  }\n\n  if (this.pipefilter) this.pipefilter(response, dest);\n}; // Composable API\n\n\nRequest.prototype.setHeader = function (name, value, clobber) {\n  if (clobber === undefined) clobber = true;\n  if (clobber || !this.hasHeader(name)) this.headers[name] = value;else this.headers[this.hasHeader(name)] += ',' + value;\n  return this;\n};\n\nRequest.prototype.setHeaders = function (headers) {\n  for (var i in headers) {\n    this.setHeader(i, headers[i]);\n  }\n\n  return this;\n};\n\nRequest.prototype.hasHeader = function (header, headers) {\n  var headers = Object.keys(headers || this.headers),\n      lheaders = headers.map(function (h) {\n    return h.toLowerCase();\n  });\n  header = header.toLowerCase();\n\n  for (var i = 0; i < lheaders.length; i++) {\n    if (lheaders[i] === header) return headers[i];\n  }\n\n  return false;\n};\n\nvar hasHeader = Request.prototype.hasHeader;\n\nRequest.prototype.qs = function (q, clobber) {\n  var base;\n  if (!clobber && this.uri.query) base = qs.parse(this.uri.query);else base = {};\n\n  for (var i in q) {\n    base[i] = q[i];\n  }\n\n  if (qs.stringify(base) === '') {\n    return this;\n  }\n\n  this.uri = url.parse(this.uri.href.split('?')[0] + '?' + qs.stringify(base));\n  this.url = this.uri;\n  this.path = this.uri.path;\n  return this;\n};\n\nRequest.prototype.form = function (form) {\n  if (form) {\n    this.setHeader('content-type', 'application/x-www-form-urlencoded; charset=utf-8');\n    this.body = qs.stringify(form).toString('utf8');\n    return this;\n  } // create form-data object\n\n\n  this._form = new FormData();\n  return this._form;\n};\n\nRequest.prototype.multipart = function (multipart) {\n  var self = this;\n  self.body = [];\n\n  if (!self.hasHeader('content-type')) {\n    self.setHeader('content-type', 'multipart/related; boundary=' + self.boundary);\n  } else {\n    var headerName = self.hasHeader('content-type');\n    self.setHeader(headerName, self.headers[headerName].split(';')[0] + '; boundary=' + self.boundary);\n  }\n\n  if (!multipart.forEach) throw new Error('Argument error, options.multipart.');\n\n  if (self.preambleCRLF) {\n    self.body.push(new Buffer('\\r\\n'));\n  }\n\n  multipart.forEach(function (part) {\n    var body = part.body;\n    if (body == null) throw Error('Body attribute missing in multipart.');\n    delete part.body;\n    var preamble = '--' + self.boundary + '\\r\\n';\n    Object.keys(part).forEach(function (key) {\n      preamble += key + ': ' + part[key] + '\\r\\n';\n    });\n    preamble += '\\r\\n';\n    self.body.push(new Buffer(preamble));\n    self.body.push(new Buffer(body));\n    self.body.push(new Buffer('\\r\\n'));\n  });\n  self.body.push(new Buffer('--' + self.boundary + '--'));\n  return self;\n};\n\nRequest.prototype.json = function (val) {\n  var self = this;\n  if (!self.hasHeader('accept')) self.setHeader('accept', 'application/json');\n  this._json = true;\n\n  if (typeof val === 'boolean') {\n    if (typeof this.body === 'object') {\n      this.body = safeStringify(this.body);\n      if (!self.hasHeader('content-type')) self.setHeader('content-type', 'application/json');\n    }\n  } else {\n    this.body = safeStringify(val);\n    if (!self.hasHeader('content-type')) self.setHeader('content-type', 'application/json');\n  }\n\n  return this;\n};\n\nRequest.prototype.getHeader = function (name, headers) {\n  var result, re, match;\n  if (!headers) headers = this.headers;\n  Object.keys(headers).forEach(function (key) {\n    re = new RegExp(name, 'i');\n    match = key.match(re);\n    if (match) result = headers[key];\n  });\n  return result;\n};\n\nvar getHeader = Request.prototype.getHeader;\n\nRequest.prototype.auth = function (user, pass, sendImmediately) {\n  if (typeof user !== 'string' || pass !== undefined && typeof pass !== 'string') {\n    throw new Error('auth() received invalid user or password');\n  }\n\n  this._user = user;\n  this._pass = pass;\n  this._hasAuth = true;\n  var header = typeof pass !== 'undefined' ? user + ':' + pass : user;\n\n  if (sendImmediately || typeof sendImmediately == 'undefined') {\n    this.setHeader('authorization', 'Basic ' + toBase64(header));\n    this._sentAuth = true;\n  }\n\n  return this;\n};\n\nRequest.prototype.aws = function (opts, now) {\n  if (!now) {\n    this._aws = opts;\n    return this;\n  }\n\n  var date = new Date();\n  this.setHeader('date', date.toUTCString());\n  var auth = {\n    key: opts.key,\n    secret: opts.secret,\n    verb: this.method.toUpperCase(),\n    date: date,\n    contentType: this.getHeader('content-type') || '',\n    md5: this.getHeader('content-md5') || '',\n    amazonHeaders: aws.canonicalizeHeaders(this.headers)\n  };\n\n  if (opts.bucket && this.path) {\n    auth.resource = '/' + opts.bucket + this.path;\n  } else if (opts.bucket && !this.path) {\n    auth.resource = '/' + opts.bucket;\n  } else if (!opts.bucket && this.path) {\n    auth.resource = this.path;\n  } else if (!opts.bucket && !this.path) {\n    auth.resource = '/';\n  }\n\n  auth.resource = aws.canonicalizeResource(auth.resource);\n  this.setHeader('authorization', aws.authorization(auth));\n  return this;\n};\n\nRequest.prototype.httpSignature = function (opts) {\n  var req = this;\n  httpSignature.signRequest({\n    getHeader: function (header) {\n      return getHeader(header, req.headers);\n    },\n    setHeader: function (header, value) {\n      req.setHeader(header, value);\n    },\n    method: this.method,\n    path: this.path\n  }, opts);\n  debug('httpSignature authorization', this.getHeader('authorization'));\n  return this;\n};\n\nRequest.prototype.hawk = function (opts) {\n  this.setHeader('Authorization', hawk.client.header(this.uri, this.method, opts).field);\n};\n\nRequest.prototype.oauth = function (_oauth) {\n  var form;\n\n  if (this.hasHeader('content-type') && this.getHeader('content-type').slice(0, 'application/x-www-form-urlencoded'.length) === 'application/x-www-form-urlencoded') {\n    form = qs.parse(this.body);\n  }\n\n  if (this.uri.query) {\n    form = qs.parse(this.uri.query);\n  }\n\n  if (!form) form = {};\n  var oa = {};\n\n  for (var i in form) oa[i] = form[i];\n\n  for (var i in _oauth) oa['oauth_' + i] = _oauth[i];\n\n  if (!oa.oauth_version) oa.oauth_version = '1.0';\n  if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString();\n  if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '');\n  oa.oauth_signature_method = 'HMAC-SHA1';\n  var consumer_secret = oa.oauth_consumer_secret;\n  delete oa.oauth_consumer_secret;\n  var token_secret = oa.oauth_token_secret;\n  delete oa.oauth_token_secret;\n  var timestamp = oa.oauth_timestamp;\n  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname;\n  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret); // oa.oauth_signature = signature\n\n  for (var i in form) {\n    if (i.slice(0, 'oauth_') in _oauth) {// skip\n    } else {\n      delete oa['oauth_' + i];\n      if (i !== 'x_auth_mode') delete oa[i];\n    }\n  }\n\n  oa.oauth_timestamp = timestamp;\n  var authHeader = 'OAuth ' + Object.keys(oa).sort().map(function (i) {\n    return i + '=\"' + oauth.rfc3986(oa[i]) + '\"';\n  }).join(',');\n  authHeader += ',oauth_signature=\"' + oauth.rfc3986(signature) + '\"';\n  this.setHeader('Authorization', authHeader);\n  return this;\n};\n\nRequest.prototype.jar = function (jar) {\n  var cookies;\n\n  if (this._redirectsFollowed === 0) {\n    this.originalCookieHeader = this.getHeader('cookie');\n  }\n\n  if (!jar) {\n    // disable cookies\n    cookies = false;\n    this._disableCookies = true;\n  } else {\n    var targetCookieJar = jar && jar.getCookieString ? jar : globalCookieJar;\n    var urihref = this.uri.href; //fetch cookie in the Specified host\n\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref);\n    }\n  } //if need cookie and cookie is not empty\n\n\n  if (cookies && cookies.length) {\n    if (this.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      this.setHeader('cookie', this.originalCookieHeader + '; ' + cookies);\n    } else {\n      this.setHeader('cookie', cookies);\n    }\n  }\n\n  this._jar = jar;\n  return this;\n}; // Stream API\n\n\nRequest.prototype.pipe = function (dest, opts) {\n  if (this.response) {\n    if (this._destdata) {\n      throw new Error(\"You cannot pipe after data has been emitted from the response.\");\n    } else if (this._ended) {\n      throw new Error(\"You cannot pipe after the response has been ended.\");\n    } else {\n      stream.Stream.prototype.pipe.call(this, dest, opts);\n      this.pipeDest(dest);\n      return dest;\n    }\n  } else {\n    this.dests.push(dest);\n    stream.Stream.prototype.pipe.call(this, dest, opts);\n    return dest;\n  }\n};\n\nRequest.prototype.write = function () {\n  if (!this._started) this.start();\n  return this.req.write.apply(this.req, arguments);\n};\n\nRequest.prototype.end = function (chunk) {\n  if (chunk) this.write(chunk);\n  if (!this._started) this.start();\n  this.req.end();\n};\n\nRequest.prototype.pause = function () {\n  if (!this.response) this._paused = true;else this.response.pause.apply(this.response, arguments);\n};\n\nRequest.prototype.resume = function () {\n  if (!this.response) this._paused = false;else this.response.resume.apply(this.response, arguments);\n};\n\nRequest.prototype.destroy = function () {\n  if (!this._ended) this.end();else if (this.response) this.response.destroy();\n};\n\nfunction toJSON() {\n  return getSafe(this, '__' + ((1 + Math.random()) * 0x10000 | 0).toString(16));\n}\n\nRequest.prototype.toJSON = toJSON;\nmodule.exports = Request;","map":null,"metadata":{},"sourceType":"script"}